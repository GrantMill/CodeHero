@page "/agents/chat"
@rendermode InteractiveServer
@using CodeHero.Web.Services
@using Microsoft.JSInterop
@using System.Text
@inject IMcpClient Client
@inject IHttpClientFactory HttpFactory
@inject RagClient Rag
@inject ILogger<AgentsChat> Log
@inject IJSRuntime JS
@inject NavigationManager Nav
@inject IConfiguration Cfg
@inject IAgentService Agent

<h3 class="text-body">Chat</h3>

@if (!string.IsNullOrWhiteSpace(alertMessage))
{
 <div class="alert alert-@alertKind" role="alert">@alertMessage</div>
}

<div class="form-check form-switch mb-2">
    <input class="form-check-input" type="checkbox" id="showFinalOnly" @bind="showFinalOnly" />
    <label class="form-check-label" for="showFinalOnly">Show only final answer (hide intermediate diagnostics)</label>
</div>

<div class="border rounded p-2 bg-body-tertiary" style="height:50vh; overflow:auto;">
 @if (messages.Count ==0)
 {
 <div class="text-secondary">Say “list requirements” or “read requirement zero zero one”.</div>
 }
 @foreach (var m in messages)
 {
 <div class="mb-2">
     @* Normalize role display: support suffixes like 'codehero.rephrase' and 'codehero.final' *@
     @{ 
         var roleParts = (m.Role ?? string.Empty).Split('.');
         var baseRole = roleParts.Length > 0 ? roleParts[0] : (m.Role ?? string.Empty);
         var subRole = roleParts.Length > 1 ? roleParts[1] : string.Empty;
         var displayRole = baseRole switch
         {
             "you" => "You",
             "agent" => "Agent",
             "codehero" => "CodeHero",
             "error" => "Error",
             _ => (baseRole ?? string.Empty)
         };
     }
     <strong class="text-body">@displayRole@if(!string.IsNullOrEmpty(subRole)){<text> (@subRole)</text>}</strong>
     <pre class="mb-0 bg-transparent text-body" style="white-space:pre-wrap">@m.Text</pre>
 </div>
 }
 <div @ref="bottom"></div>
</div>

@if (showApproval)
{
 <div class="modal d-block" tabindex="-1" style="background:rgba(0,0,0,.35)">
 <div class="modal-dialog modal-lg modal-dialog-centered">
 <div class="modal-content">
 <div class="modal-header">
 <h5 class="modal-title text-body">Approval required</h5>
 <button type="button" class="btn-close" aria-label="Close" @onclick="CancelPendingAsync"></button>
 </div>
 <div class="modal-body">
 @if (!string.IsNullOrWhiteSpace(approvalHeader))
 {
 <div class="small text-secondary mb-2">@approvalHeader</div>
 }
 <pre class="border rounded p-2 bg-body text-body" style="white-space:pre; max-height:50vh; overflow:auto">@approvalDiff</pre>
 </div>
 <div class="modal-footer">
 <button class="btn btn-outline-secondary" @onclick="CancelPendingAsync">Cancel</button>
 <button class="btn btn-primary" @onclick="ApprovePendingAsync">Approve</button>
 </div>
 </div>
 </div>
 </div>
}

<div class="card mt-3">
 <div class="card-header">Conversational mode</div>
 <div class="card-body">
 <div class="d-flex align-items-center gap-2">
 @if (enableContinuous)
 {
 <button class="btn @(continuous?"btn-warning":"btn-outline-warning")" data-testid="continuous-toggle" @onclick="ToggleContinuous">@(continuous?"Continuous: On":"Continuous: Off")</button>
 <span class="badge rounded-pill text-bg-@(phase=="Listening"?"primary":phase=="Speaking"?"success":phase=="Thinking"?"secondary":"light")">@phase</span>
 }
 else
 {
 <span class="text-secondary">Continuous mode is disabled by configuration.</span>
 }
 </div>

 @if (enableContinuous)
 {
 <div class="row row-cols-1 row-cols-md-2 g-2 mt-3">
 <div class="col">
 <label class="form-label mb-1">Sensitivity (lower = more sensitive)</label>
 <input type="range" class="form-range" min="0.001" max="0.05" step="0.001" @bind-value="vadThreshold" @bind-value:event="oninput" @onchange="ApplyContinuousSettings" />
 <div class="small text-secondary">threshold=@vadThreshold:F3</div>
 </div>
 <div class="col">
 <label class="form-label mb-1">Silence window (ms)</label>
 <input type="range" class="form-range" min="200" max="2000" step="50" @bind-value="vadSilenceMs" @bind-value:event="oninput" @onchange="ApplyContinuousSettings" />
 <div class="small text-secondary">minSilenceMs=@vadSilenceMs</div>
 </div>
 </div>
 }

 <div class="mt-2 small text-secondary">@recStatus</div>
 @if (!string.IsNullOrWhiteSpace(supportStatus))
 {
 <div class="small text-secondary">@supportStatus</div>
 }
 <audio class="mt-2 w-100" controls @ref="audioRef"></audio>
 </div>
 <div class="card-footer text-secondary">Continuous On will listen, transcribe, call the agent, and play the reply.</div>
</div>

@code {
    record Msg(string Role, string Text);
    List<Msg> messages = new();
    string status = string.Empty;
    ElementReference bottom;
    ElementReference audioRef;
    string recStatus = string.Empty;
    string supportStatus = string.Empty;
    string lastTranscript = string.Empty;
    string agentReply = string.Empty;
    bool showFinalOnly = true;

    // Alerts
    string? alertMessage;
    string alertKind = "info";

    // Approval modal state
    bool showApproval = false;
    string? approvalHeader;
    string? approvalDiff;

    // Continuous mode
    bool enableContinuous = false;
    bool continuous = false;
    string phase = "Idle";
    DotNetObjectReference<AgentsChat>? selfRef;
    SemaphoreSlim phraseGate = new(1,1);
    CancellationTokenSource? continuousCts;

    // VAD sliders
    double vadThreshold =0.010; // default
    int vadSilenceMs =800;

    // Intent regexes (match HelperRoutingAgentService heuristics)
    private static readonly System.Text.RegularExpressions.Regex ScribeKeywords = new System.Text.RegularExpressions.Regex("\\b(create|add|new requirement|draft requirement|scribe)\\b", System.Text.RegularExpressions.RegexOptions.IgnoreCase | System.Text.RegularExpressions.RegexOptions.Compiled);
    private static readonly System.Text.RegularExpressions.Regex ReqNouns = new System.Text.RegularExpressions.Regex("\\b(req|requirement|requirements|REQ-)\\b", System.Text.RegularExpressions.RegexOptions.IgnoreCase | System.Text.RegularExpressions.RegexOptions.Compiled);
    private static readonly System.Text.RegularExpressions.Regex ListVerbs = new System.Text.RegularExpressions.Regex("\\b(list|show|display)\\b", System.Text.RegularExpressions.RegexOptions.IgnoreCase | System.Text.RegularExpressions.RegexOptions.Compiled);
    private static readonly System.Text.RegularExpressions.Regex ReadVerb = new System.Text.RegularExpressions.Regex("\\bread\\b", System.Text.RegularExpressions.RegexOptions.IgnoreCase | System.Text.RegularExpressions.RegexOptions.Compiled);

    protected override void OnInitialized()
    {
        enableContinuous = Cfg.GetValue("Features:ContinuousDictation", true);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && enableContinuous)
        {
            selfRef = DotNetObjectReference.Create(this);
        }
        await Task.CompletedTask;
    }

    public async ValueTask DisposeAsync()
    {
        if (continuous)
        {
            try { await JS.InvokeVoidAsync("codeheroAudio.continuous.stop"); } catch { }
            continuousCts?.Cancel();
        }
        selfRef?.Dispose();
        phraseGate.Dispose();
    }

    async Task ApplyContinuousSettings(ChangeEventArgs _)
    {
        if (!continuous) return;
        try
        {
            await JS.InvokeVoidAsync("codeheroAudio.continuous.stop");
            await JS.InvokeVoidAsync("codeheroAudio.continuous.start", selfRef, new { threshold = vadThreshold, minSilenceMs = vadSilenceMs });
        }
        catch { }
    }

    async Task LoadAudioTag(byte[] bytes)
    {
        var b64 = Convert.ToBase64String(bytes);
        await JS.InvokeVoidAsync("codeheroAudio.load", audioRef, "data:audio/wav;base64," + b64);
    }

    async Task ApprovePendingAsync()
    {
        showApproval = false;
        var you = "approve";
        messages.Add(new Msg("you", you));

        // Use direct SocketsHttpHandler + HttpClient to avoid global resilience handlers (30s cancellations)
        using var handler = new System.Net.Http.SocketsHttpHandler
        {
            AutomaticDecompression = System.Net.DecompressionMethods.GZip | System.Net.DecompressionMethods.Deflate,
            PooledConnectionLifetime = TimeSpan.FromMinutes(10),
            Expect100ContinueTimeout = TimeSpan.Zero,
            UseProxy = false
        };
        using var client = new System.Net.Http.HttpClient(handler) { Timeout = System.Threading.Timeout.InfiniteTimeSpan };
        if (client.BaseAddress is null) client.BaseAddress = new Uri(Nav.BaseUri, UriKind.Absolute);
        client.DefaultRequestVersion = System.Net.HttpVersion.Version11;

        var replyResp = await client.PostAsync("api/agent/chat", new StringContent(you));
        if (replyResp.IsSuccessStatusCode)
        {
            var reply = await replyResp.Content.ReadAsStringAsync();
            messages.Add(new Msg("agent", reply));
            if (reply.StartsWith("[fs/writeText] Saved:", StringComparison.OrdinalIgnoreCase))
            {
                alertKind = "success"; alertMessage = reply;
            }
            else if (reply.StartsWith("[approval]", StringComparison.OrdinalIgnoreCase))
            {
                messages.Add(new Msg("agent", reply));
                ShowApproval(reply);
                alertMessage = null;
            }
            else
            {
                alertKind = "info"; alertMessage = reply;
                var tts = await client.PostAsync("api/tts?voice=en-US-JennyNeural", new StringContent(reply));
                if (tts.IsSuccessStatusCode)
                {
                    var wav = await tts.Content.ReadAsByteArrayAsync();
                    await LoadAudioTag(wav);
                }
            }
        }
        await InvokeAsync(StateHasChanged);
    }

    async Task CancelPendingAsync()
    {
        showApproval = false;
        var you = "cancel";
        messages.Add(new Msg("you", you));

        using var handler = new System.Net.Http.SocketsHttpHandler
        {
            AutomaticDecompression = System.Net.DecompressionMethods.GZip | System.Net.DecompressionMethods.Deflate,
            PooledConnectionLifetime = TimeSpan.FromMinutes(10),
            Expect100ContinueTimeout = TimeSpan.Zero,
            UseProxy = false
        };
        using var client = new System.Net.Http.HttpClient(handler) { Timeout = System.Threading.Timeout.InfiniteTimeSpan };
        if (client.BaseAddress is null) client.BaseAddress = new Uri(Nav.BaseUri, UriKind.Absolute);
        client.DefaultRequestVersion = System.Net.HttpVersion.Version11;

        var replyResp = await client.PostAsync("api/agent/chat", new StringContent(you));
        if (replyResp.IsSuccessStatusCode)
        {
            var reply = await replyResp.Content.ReadAsStringAsync();
            messages.Add(new Msg("agent", reply));
            alertKind = "warning"; alertMessage = reply;
        }
        await InvokeAsync(StateHasChanged);
    }

    // Continuous mode helpers
    async Task ToggleContinuous()
    {
        if (!enableContinuous) return;
        if (!continuous)
        {
            // Capability check (optional)
            try
            {
                var caps = await JS.InvokeAsync<AudioCapabilities>("codeheroAudio.support");
                supportStatus = $"secure={caps.secure}, mediaDevices={caps.hasMediaDevices}, getUserMedia={caps.hasGetUserMedia}, mediaRecorder={caps.hasMediaRecorder}, pref={caps.preferred ?? "n/a"}, mic={caps.micPerm}";
            }
            catch { }

            continuousCts = new CancellationTokenSource();
            phase = "Listening";
            await JS.InvokeVoidAsync("codeheroAudio.continuous.start", selfRef, new { threshold = vadThreshold, minSilenceMs = vadSilenceMs });
            continuous = true;
        }
        else
        {
            await JS.InvokeVoidAsync("codeheroAudio.continuous.stop");
            continuousCts?.Cancel();
            continuous = false;
            phase = "Idle";
        }
    }

    [JSInvokable]
    public async Task OnVADState(string state)
    {
        phase = state switch { "speaking" => "Speaking", "listening" => "Listening", _ => phase };
        await InvokeAsync(StateHasChanged);
    }

    [JSInvokable]
    public async Task OnPhrase(string base64)
    {
        // Allow only one phrase in flight to avoid overlap
        if (!await phraseGate.WaitAsync(0)) return;
        using var gateReleaser = new Releaser(phraseGate);

        // Allow longer runtime for RAG/Foundry calls; use the server-configured Foundry attempt timeout
        // to avoid UI-side cancellation that is shorter than server caps. Add a small buffer.
        var serverTimeoutSec = Cfg.GetValue<int?>("Resilience:FoundryAttemptTimeoutSeconds") ?? 120;
        var uiTimeoutSec = Math.Max(60, serverTimeoutSec + 5); // at least 60s, or server timeout + buffer
        using var timeoutCts = new CancellationTokenSource(TimeSpan.FromSeconds(uiTimeoutSec));
        using var linked = CancellationTokenSource.CreateLinkedTokenSource(timeoutCts.Token, continuousCts?.Token ?? CancellationToken.None);
        try
        {
            var bytes = Convert.FromBase64String(base64);
            // Send to STT
            using var handler = new System.Net.Http.SocketsHttpHandler
            {
                AutomaticDecompression = System.Net.DecompressionMethods.GZip | System.Net.DecompressionMethods.Deflate,
                PooledConnectionLifetime = TimeSpan.FromMinutes(10),
                Expect100ContinueTimeout = TimeSpan.Zero,
                UseProxy = false
            };
            using var client = new System.Net.Http.HttpClient(handler) { Timeout = System.Threading.Timeout.InfiniteTimeSpan };
            if (client.BaseAddress is null) client.BaseAddress = new Uri(Nav.BaseUri, UriKind.Absolute);
            client.DefaultRequestVersion = System.Net.HttpVersion.Version11;
            
            using var content = new ByteArrayContent(bytes);
            content.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue("audio/wav");
            var resp = await client.PostAsync("api/stt", content, linked.Token);
            var text = resp.IsSuccessStatusCode ? (await resp.Content.ReadAsStringAsync(linked.Token)) : string.Empty;
            if (!string.IsNullOrWhiteSpace(text))
            {
                lastTranscript = text;
                messages.Add(new Msg("you", text));
                phase = "Thinking";
                // Centralize decision in HelperRoutingAgentService: UI delegates all requests to the helper and
                // renders annotated responses the helper returns. The helper will decide whether to call MCP or RAG.
                try
                {
                    var history = BuildChatHistoryFromMessages();
                    var agentResp = await Agent.ChatAsync(text, history, linked.Token) ?? string.Empty;

                    // If helper produced an annotated diagnostic (contains marker '(rephrase)'), parse and render
                    if (agentResp.IndexOf("(rephrase)", StringComparison.OrdinalIgnoreCase) >= 0)
                    {
                        messages.Add(new Msg("agent", "Asking"));

                        // Simple parser: capture sections between marker lines like '(rephrase)', '(search)', '(answer request)', '(final answer)'

                        var sections = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                        var lines = agentResp.Split(new[] { '\r', '\n' }, StringSplitOptions.None);
                        string? curKey = null;
                        var curSb = new System.Text.StringBuilder();
                        foreach (var ln in lines)
                        {
                            var trimmed = ln.Trim();
                            if (trimmed.Length == 0)
                            {
                                if (curKey is not null)
                                {
                                    curSb.AppendLine();
                                }
                                continue;
                            }
                            if (trimmed.StartsWith("(") && trimmed.EndsWith(")"))
                            {
                                // save previous
                                if (curKey is not null)
                                {
                                    sections[curKey] = curSb.ToString().Trim();
                                    curSb.Clear();
                                }
                                curKey = trimmed.Substring(1, trimmed.Length - 2).Trim();
                                continue;
                            }
                            if (curKey is null) continue; // skip until we hit first marker
                            curSb.AppendLine(ln);
                        }
                        if (curKey is not null)
                            sections[curKey] = curSb.ToString().Trim();

                        // Render rephrase
                        if (sections.TryGetValue("rephrase", out var reph))
                        {
                            messages.Add(new Msg("codehero.rephrase", string.IsNullOrWhiteSpace(reph) ? "(no rephrase)" : reph));
                        }

                        // Optionally render search and request when visible
                        if (!showFinalOnly)
                        {
                            if (sections.TryGetValue("search", out var search))
                            {
                                messages.Add(new Msg("agent", "Search results"));
                                messages.Add(new Msg("codehero.search", string.IsNullOrWhiteSpace(search) ? "(no search)" : search));
                            }
                            if (sections.TryGetValue("answer request", out var reqjson))
                            {
                                messages.Add(new Msg("agent", "Model input"));
                                messages.Add(new Msg("codehero.request", string.IsNullOrWhiteSpace(reqjson) ? "(no answer request json)" : reqjson));
                            }
                        }

                        // Final answer
                        if (sections.TryGetValue("final answer", out var final))
                        {
                            messages.Add(new Msg("codehero.final", string.IsNullOrWhiteSpace(final) ? "(no answer)" : final));
                            if (!string.IsNullOrWhiteSpace(final))
                            {
                                var tts = await client.PostAsync("api/tts?voice=en-US-JennyNeural", new StringContent(final), linked.Token);
                                if (tts.IsSuccessStatusCode)
                                {
                                    var wav = await tts.Content.ReadAsByteArrayAsync(linked.Token);
                                    await LoadAudioTag(wav);
                                }
                            }
                        }
                    }
                    else
                    {
                        // No annotations: display as single final answer from agent/orchestrator
                        messages.Add(new Msg("agent", "Asking"));
                        messages.Add(new Msg("codehero.final", agentResp));
                        if (!string.IsNullOrWhiteSpace(agentResp))
                        {
                            var tts = await client.PostAsync("api/tts?voice=en-US-JennyNeural", new StringContent(agentResp), linked.Token);
                            if (tts.IsSuccessStatusCode)
                            {
                                var wav = await tts.Content.ReadAsByteArrayAsync(linked.Token);
                                await LoadAudioTag(wav);
                            }
                        }
                    }
                }
                 catch (OperationCanceledException)
                 {
                     messages.Add(new Msg("error", "Timed out processing phrase."));
                 }
                 catch (Exception ex)
                 {
                     messages.Add(new Msg("error", ex.Message));
                 }
                 finally
                 {
                     phase = continuous ? "Listening" : "Idle";
                     await InvokeAsync(StateHasChanged);
                 }
             }
        }
        catch (OperationCanceledException)
        {
            messages.Add(new Msg("error", "Timed out processing phrase."));
        }
        catch (Exception ex)
        {
            messages.Add(new Msg("error", ex.Message));
        }
        finally
        {
            phase = continuous ? "Listening" : "Idle";
            await InvokeAsync(StateHasChanged);
        }
    }

    void ShowApproval(string reply)
    {
        showApproval = true;
        // Split header and diff at first newline
        var idx = reply.IndexOf('\n');
        if (idx >0)
        {
            approvalHeader = reply.Substring(0, idx).Trim();
            approvalDiff = reply.Substring(idx +1);
        }
        else
        {
            approvalHeader = "Approval required";
            approvalDiff = reply;
        }
        StateHasChanged();
    }

    // Try to extract the final, user-facing answer from a fuller diagnostic reply.
    // Strategies:
    // - If reply contains a '(final answer)' marker, take the following text
    // - If reply is JSON and contains a 'summary' property, return that
    // - Otherwise return the original reply
    private static string ExtractFinalAnswer(string reply)
    {
        if (string.IsNullOrWhiteSpace(reply)) return reply;
        try
        {
            var marker = "(final answer)";
            var idx = reply.IndexOf(marker, StringComparison.OrdinalIgnoreCase);
            if (idx >= 0)
            {
                var after = reply.Substring(idx + marker.Length).Trim();
                if (!string.IsNullOrEmpty(after)) return after;
            }

            // Try JSON parse for 'summary' field
            var trimmed = reply.Trim();
            if (trimmed.StartsWith('{') || trimmed.StartsWith('['))
            {
                using var doc = System.Text.Json.JsonDocument.Parse(trimmed);
                if (doc.RootElement.TryGetProperty("summary", out var sum) && sum.ValueKind == System.Text.Json.JsonValueKind.String)
                {
                    return sum.GetString() ?? trimmed;
                }
                // fallback: if root has 'output' or 'choices'[0].message.content
                if (doc.RootElement.TryGetProperty("output", out var outEl) && outEl.ValueKind == System.Text.Json.JsonValueKind.String)
                    return outEl.GetString() ?? trimmed;
                if (doc.RootElement.TryGetProperty("choices", out var choices) && choices.ValueKind == System.Text.Json.JsonValueKind.Array && choices.GetArrayLength() > 0)
                {
                    var first = choices[0];
                    if (first.TryGetProperty("message", out var msg) && msg.TryGetProperty("content", out var contentEl) && contentEl.ValueKind == System.Text.Json.JsonValueKind.String)
                        return contentEl.GetString() ?? trimmed;
                }
            }
        }
        catch { /* ignore parse errors */ }
        return reply;
    }

    // Build a ChatTurn history from the UI messages so the helper/RAG has prior context.
    IReadOnlyList<ChatTurn> BuildChatHistoryFromMessages()
    {
        var turns = new List<ChatTurn>();
        for (int i = 0; i < messages.Count; i++)
        {
            var m = messages[i];
            if (string.Equals(m.Role, "you", StringComparison.OrdinalIgnoreCase))
            {
                var user = m.Text ?? string.Empty;
                var sb = new StringBuilder();
                int j = i + 1;
                for (; j < messages.Count && !string.Equals(messages[j].Role, "you", StringComparison.OrdinalIgnoreCase); j++)
                {
                    // include assistant and codehero messages as assistant content
                    var roleBase = (messages[j].Role ?? string.Empty).Split('.')[0];
                    if (string.Equals(roleBase, "agent", StringComparison.OrdinalIgnoreCase) || string.Equals(roleBase, "codehero", StringComparison.OrdinalIgnoreCase) || string.Equals(roleBase, "error", StringComparison.OrdinalIgnoreCase))
                    {
                        if (sb.Length > 0) sb.Append('\n');
                        sb.Append(messages[j].Text ?? string.Empty);
                    }
                }
                var assistant = sb.ToString();
                turns.Add(new ChatTurn(user, assistant, DateTimeOffset.UtcNow));
                i = j - 1;
            }
        }
        return turns;
    }

    private sealed class Releaser : IAsyncDisposable, IDisposable
    {
        private readonly SemaphoreSlim _gate;
        public Releaser(SemaphoreSlim gate) => _gate = gate;
        public void Dispose() => _gate.Release();
        public ValueTask DisposeAsync() { _gate.Release(); return ValueTask.CompletedTask; }
    }
}