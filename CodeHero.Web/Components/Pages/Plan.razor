@page "/plan"
@rendermode InteractiveServer
@using System.Text.RegularExpressions
@using CodeHero.Web.Services
@using Markdig
@inject FileStore Store
@inject Markdig.MarkdownPipeline Md

<h3>Backlog</h3>

<div class="card mb-3">
 <div class="card-body">
 <div class="mermaid">@roadmap</div>
 </div>
 <div class="card-footer small text-muted">Source: docs/roadmap.mmd</div>
</div>

<p class="text-muted">One list, prioritized top-to-bottom. <span title="Agent" class="bi bi-robot"></span> = agent task, <span title="Human" class="bi bi-person-badge"></span> = human task.</p>

<div class="card">
 <div class="card-body">
 @for (int i =0; i < items.Count; i++)
 {
 var item = items[i];
 <div class="mb-1">
 @if (item.IsTask)
 {
 <div class="d-flex align-items-center gap-2">
 <span class="fs-5 @(item.IsAgent ? "bi bi-robot text-warning" : "bi bi-person-badge text-info")" title="@(item.IsAgent ? "Agent" : "Human")"></span>
 <input type="checkbox" class="form-check-input" checked="@item.Checked" @onchange="(e)=>Toggle(i, e.Value)" />
                        <span class="ms-2">@((MarkupString)Markdig.Markdown.ToHtml(item.Text, Md))</span>
 </div>
 }
 else
 {
                    <div class="text-muted small">@((MarkupString)Markdig.Markdown.ToHtml(item.Text, Md))</div>
 }
 </div>
 }
 <button class="btn btn-primary mt-2" @onclick="Save">Save Backlog</button>
 </div>
 <div class="card-footer small text-muted">Source: plan/BACKLOG.md</div>
</div>

@code {
 record LineItem(int LineNumber, string Original, bool IsTask, bool Checked, bool IsAgent, string Text);
 List<LineItem> items = new();
 string roadmap = "";
 string[] originalLines = Array.Empty<string>();

 protected override void OnInitialized()
 {
 var md = Store.ReadBacklog();
 originalLines = md.Replace("\r\n","\n").Split('\n');
 items = ParseLines(originalLines).ToList();
 roadmap = Store.ReadRoadmap();
 if (string.IsNullOrWhiteSpace(roadmap))
 {
 roadmap = "gantt\n title Roadmap (missing docs/roadmap.mmd)\n dateFormat YYYY-MM-DD\n section Demo\n Placeholder :done,2025-10-22,1d";
 }
 }

 static IEnumerable<LineItem> ParseLines(string[] lines)
 {
 var list = new List<LineItem>();
 var taskRegex = new Regex(@"^\s*-\s*\[( |x|X)\]\s*\[(A|H)\]\s*(.*)$");
 for (int i =0; i < lines.Length; i++)
 {
 var line = lines[i];
 var m = taskRegex.Match(line);
 if (m.Success)
 {
 var isChecked = m.Groups[1].Value.Equals("x", StringComparison.OrdinalIgnoreCase);
 var isAgent = m.Groups[2].Value.Equals("A", StringComparison.OrdinalIgnoreCase);
 var text = m.Groups[3].Value;
 list.Add(new LineItem(i, line, true, isChecked, isAgent, text));
 }
 else
 {
 // keep other markdown/comments/headers as-is
 list.Add(new LineItem(i, line, false, false, false, line));
 }
 }
 return list;
 }

 void Toggle(int index, object? value)
 {
 var it = items[index];
 var isChecked = value is bool b && b;
 items[index] = it with { Checked = isChecked };
 }

 void Save()
 {
 // update originalLines for task lines only
 foreach (var it in items)
 {
 if (it.IsTask)
 {
 var checkbox = it.Checked ? "x" : " ";
 var kind = it.IsAgent ? "A" : "H";
 originalLines[it.LineNumber] = $"- [{checkbox}] [{kind}] {it.Text}";
 }
 }
 var outMd = string.Join("\n", originalLines) + "\n";
 Store.WriteBacklog(outMd);
 }
}
