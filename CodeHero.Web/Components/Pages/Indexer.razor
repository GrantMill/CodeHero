@page "/indexer"
@rendermode InteractiveServer
@using System.Text.Json
@inject HttpClient Http
@inject NavigationManager Nav
@inject IConfiguration Configuration
@inject IJSRuntime JS

<h3>Repository Indexer</h3>

<button class="btn btn-primary" @onclick="RunIndex" disabled="@isRunning">Run Indexer</button>
<span class="ml-2">@statusMessage</span>

@if (!string.IsNullOrEmpty(rawResponse))
{
    <div class="mt-2 alert alert-secondary" style="white-space:pre-wrap; font-family:monospace;">Raw response: @rawResponse</div>
}

<h4 class="mt-3">History</h4>
@if (history is null)
{
    <p>Loading history…</p>
}
else if (!history.Any())
{
    <p class="text-muted">No history found.</p>
}
else
{
    <table class="table table-sm">
        <thead>
            <tr>
                <th>Time (UTC)</th>
                <th>Success</th>
                <th>Docs</th>
                <th>Message</th>
                <th>Error Details</th>
            </tr>
        </thead>
        <tbody>
            @foreach (var r in history.OrderByDescending(h => h.Timestamp))
            {
                <tr>
                    <td>@r.Timestamp.ToUniversalTime()</td>
                    <td>@(r.Success ? "Yes" : "No")</td>
                    <td>@r.DocumentsIndexed</td>
                    <td style="word-break:break-word">@r.Message</td>
                    <td style="word-break:break-word">@r.ErrorDetails</td>
                </tr>
            }
        </tbody>
    </table>
}

@code {
    private const string HistoryStorageKey = "codehero.indexer.history";
    private IJSObjectReference? _storageModule;

    private bool isRunning;
    private string statusMessage = string.Empty;
    private string rawResponse = string.Empty;
    private IndexerRunResult[]? history;

    protected override async Task OnInitializedAsync()
    {
        await LoadHistoryFromLocalStorage(); // show immediately
        await LoadHistory();                 // then sync from server (if available)
    }

    private async Task EnsureStorageModule()
    {
        _storageModule ??= await JS.InvokeAsync<IJSObjectReference>("import", "./js/localStorage.js");
    }

    private async Task SaveHistoryToLocalStorage()
    {
        try
        {
            await EnsureStorageModule();
            var opts = new JsonSerializerOptions { PropertyNamingPolicy = JsonNamingPolicy.CamelCase };
            var payload = JsonSerializer.Serialize(history ?? Array.Empty<IndexerRunResult>(), opts);
            await _storageModule!.InvokeVoidAsync("set", HistoryStorageKey, payload);
        }
        catch
        {
            // best effort; ignore client storage errors
        }
    }

    private async Task LoadHistoryFromLocalStorage()
    {
        try
        {
            await EnsureStorageModule();
            var json = await _storageModule!.InvokeAsync<string>("get", HistoryStorageKey);
            if (!string.IsNullOrWhiteSpace(json))
            {
                var opts = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
                history = JsonSerializer.Deserialize<IndexerRunResult[]>(json, opts) ?? Array.Empty<IndexerRunResult>();
                StateHasChanged();
            }
        }
        catch
        {
            // ignore client storage errors
        }
    }

    private Uri BuildFallbackUri(string relative)
    {
        var baseUrl = Configuration["ApiService:BaseUrl"]; // e.g. https://localhost:7186 or 7525
        if (string.IsNullOrWhiteSpace(baseUrl)) return Nav.ToAbsoluteUri(relative);
        return new Uri(new Uri(baseUrl.TrimEnd('/')), relative.TrimStart('/'));
    }

    private async Task<HttpResponseMessage> TryRequestWithFallback(string relative, Func<Uri, Task<HttpResponseMessage>> action)
    {
        // try same-origin first
        var defaultUri = Nav.ToAbsoluteUri(relative);
        var resp = await action(defaultUri);
        if (resp.StatusCode == System.Net.HttpStatusCode.NotFound || resp.StatusCode == System.Net.HttpStatusCode.MethodNotAllowed)
        {
            var fallbackUri = BuildFallbackUri(relative);
            resp = await action(fallbackUri);
        }
        return resp;
    }

    private async Task LoadHistory()
    {
        try
        {
            var resp = await TryRequestWithFallback("/api/search/indexer/history", uri => Http.GetAsync(uri));

            if (resp.IsSuccessStatusCode)
            {
                var txt = await resp.Content.ReadAsStringAsync();
                if (!string.IsNullOrWhiteSpace(txt))
                {
                    try
                    {
                        var opts = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
                        var server = JsonSerializer.Deserialize<IndexerRunResult[]>(txt, opts) ?? Array.Empty<IndexerRunResult>();

                        // Merge with local (prefer server by Id, then local unique)
                        var local = history ?? Array.Empty<IndexerRunResult>();
                        var merged = server.Concat(local.Where(l => !server.Any(s => s.Id == l.Id)))
                                           .OrderByDescending(h => h.Timestamp)
                                           .ToArray();
                        history = merged;
                        await SaveHistoryToLocalStorage();
                    }
                    catch
                    {
                        // Failed to parse server payload; keep whatever we had locally
                    }
                }
            }
        }
        catch
        {
            // network error; keep local
        }
        StateHasChanged();
    }

    private async Task RunIndex()
    {
        isRunning = true;
        statusMessage = "Starting...";
        rawResponse = string.Empty;
        StateHasChanged();
        try
        {
            var res = await TryRequestWithFallback("/api/search/indexer/run", uri => Http.PostAsync(uri, null));
            rawResponse = await res.Content.ReadAsStringAsync();

            if (res.StatusCode == System.Net.HttpStatusCode.Accepted)
            {
                // expected body: { jobId: "..." }
                Guid? jobId = null;
                try
                {
                    using var doc = JsonDocument.Parse(rawResponse);
                    if (doc.RootElement.TryGetProperty("jobId", out var el) && Guid.TryParse(el.GetString(), out var gid)) jobId = gid;
                }
                catch { }

                // fallback to Location header
                if (!jobId.HasValue && res.Headers.Location is not null)
                {
                    var loc = res.Headers.Location.ToString();
                    // last segment is jobId
                    var seg = loc.TrimEnd('/').Split('/').LastOrDefault();
                    if (Guid.TryParse(seg, out var gid2)) jobId = gid2;
                }

                if (!jobId.HasValue)
                {
                    statusMessage = "Started (job queued)";
                    return;
                }

                statusMessage = $"Job queued: {jobId}. Polling...";
                StateHasChanged();

                // Poll status endpoint until result available or timeout
                var statusUri = $"/api/search/indexer/status/{jobId.Value}";
                IndexerRunResult? final = null;
                var sw = System.Diagnostics.Stopwatch.StartNew();
                var timeoutMs = 120_000; // 2 minutes
                while (sw.ElapsedMilliseconds < timeoutMs)
                {
                    try
                    {
                        var pollResp = await TryRequestWithFallback(statusUri, u => Http.GetAsync(u));
                        var txt = await pollResp.Content.ReadAsStringAsync();
                        if (pollResp.IsSuccessStatusCode)
                        {
                            // If server returns queued object, it returns { status: "queued" }
                            try
                            {
                                using var doc = JsonDocument.Parse(txt);
                                if (doc.RootElement.TryGetProperty("status", out var st) && st.GetString() == "queued")
                                {
                                    // still queued
                                }
                                else
                                {
                                    // parse IndexerRunResult
                                    var opts = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
                                    final = JsonSerializer.Deserialize<IndexerRunResult>(txt, opts);
                                    if (final != null) break;
                                }
                            }
                            catch
                            {
                                // ignore parse errors
                            }
                        }
                    }
                    catch { }

                    await Task.Delay(1000);
                }

                if (final is not null)
                {
                    statusMessage = (final.Success ? "Completed: " : "Failed: ") + (final.Message ?? string.Empty);

                    // Persist locally (in case server doesn't persist history yet)
                    var list = (history?.ToList() ?? new List<IndexerRunResult>());
                    if (!list.Any(x => x.Id == final.Id)) list.Add(final);
                    history = list.OrderByDescending(x => x.Timestamp).ToArray();
                    await SaveHistoryToLocalStorage();
                }
                else
                {
                    statusMessage = "Index job timed out waiting for result (polling stopped).";
                }
            }
            else
            {
                // previous behavior: try parse immediate IndexerRunResult
                IndexerRunResult? json = null;
                try
                {
                    var opts = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
                    json = JsonSerializer.Deserialize<IndexerRunResult>(rawResponse, opts);
                }
                catch (JsonException) { }

                if (json != null)
                {
                    statusMessage = (res.IsSuccessStatusCode ? "Success: " : "Failed: ") + (json.Message ?? string.Empty);

                    // Persist locally (in case server doesn't persist history yet)
                    var list = (history?.ToList() ?? new List<IndexerRunResult>());
                    if (!list.Any(x => x.Id == json.Id))
                        list.Add(json);

                    history = list.OrderByDescending(x => x.Timestamp).ToArray();
                    await SaveHistoryToLocalStorage();
                }
                else
                {
                    statusMessage = res.IsSuccessStatusCode ? "Success" : ($"Failed: {res.ReasonPhrase}");
                }
            }
        }
        catch (Exception ex)
        {
            statusMessage = $"Error: {ex.Message}";
            rawResponse = ex.ToString();
        }
        finally
        {
            isRunning = false;
            // Try to refresh from server too (if it now persists)
            await LoadHistory();
            StateHasChanged();
        }
    }

    public class IndexerRunResult
    {
        public System.Guid Id { get; set; }
        public System.DateTimeOffset Timestamp { get; set; }
        public bool Success { get; set; }
        public string Message { get; set; } = "";
        public int DocumentsIndexed { get; set; }
        public string? ErrorDetails { get; set; }
    }
}